JAVA
=========
stringbuffer came first. stringbuilder is single-thread implementation. 
---
Java naming conventions
packages: all lowercase, prefix with TLD followed by components according to the org's internal naming conventions.
Classes: nouns, camel case starting with capital letter. 
Interfaces: like class names
Methods: verbs, camel case starting with lowercase.
Variables: camel case starting with lower case, don't start with _ or $.
Constants: all uppercase, words separated by _
---
log4j configuration in main/resources
---
3 main components of Logging
- Logger component
	log levels: 1:trace, 2:debug, 3:info,4:warn,5:error,6:fatal
	log configuration: log4j.properties(K,V)
- Appender component
	append to console,file,db
- Layout component
---
public class Demo {
	public static void main() {
		sout("main");
		sout("object 1");
		Demo d1 = new Demo();
		sout("object 2");
		Demo d2 = new Demo();
	}
	public Demo() {
		sout("Constructor")
	}
	static {
		sout("static block");
	}
	{
		sout("anonymous block");
	}
}
Output:
static block
main
object 1
anonymous block
constuctor
object 2
anonymous block
constuctor
---
COLLECTIONS

(I: interface, C: Class)
Collection (I)
-List (I)
--Vector (C)
	uses array
	starts with 10 elements increases by 10
	memory is contiguous
	is legacy class (backwards compatible) and thread safe
--ArrayList (C)
	starts w/ 10 increases by 1.5
	memory is contiguous
	not thread safe
--LinkedList (C)
	starts w/ 1 increases by 1
	doesn't use array, maintains node structure
	can work as List, Queue, Dequeue
	memory is random, not contiguous
	not thread safe
-Queue (I)
--LinkedList (C)
--PriorityQueue (C)
-Set (I)
	no duplicates, no index, unordered
--HashSet (C)
	does not preserve order of insertion
	allows one null value
---LinkedHashSet (C)
	maintains order of insertion
	uses equals() and hashcode()
--SortedSet (I)
---NavigableSet (I)
----TreeSet (C)
	stored in sorted order based on comparator
	null not allowed

Collections
	helper class w/ static methods
Collections.sort() calls Comparable or Comparator Functional interface
Comparable 
	in java.lang
	int compareTo(object): definition should be in Model class
	
Comparator 
	in java.util
	int compare(Object o1, Object o2)
		definition can be anywhere effectively can make use of lambda 

Map<K,V> (I)
--HashMap (C)
---LinkedHashMap (C)
--SortedMap (I)
---NavigableMap (I)
----TreeMap (C)
--Hashtable (C)
	no null, thread safe, legacy

interface methods are public & abstract by default
interface properites are static & final by default
Lambda is only applicable on functional interfaces
left hand side of assignment should be the interface and right hand side should be its implementing class
List l = new LinkedList();
Queue q = new LinkedList();
Dequeue dq = new LinkedList();
---
java.util.Arrays
Arrays.toString()

Problem: Getting errors/warnings in IntelliJ, but it was still compiling and running.
Solution: File > Invalidate caches > Check all three boxes > Invalidate and Restart
---
Java Print address of object 
System.identityHashCode(x)
---
// create string outside of common string pool
String s1 = new String("hello");
// move back into common string pool
s1=s1.intern();
---
Slack Two-Factor Authentication Backup Codes

543117
112947
571434
811055
999009
951731
808697
513381
996002
550327
