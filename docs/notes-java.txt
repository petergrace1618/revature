JAVA
=========
Javalin: lightweight web framework for Kotlin and Java. Supports handling requests from client and generates the responses. Is built on Jetty server. jetty is a container for javalin. it does http calls suitable for developing rest apis. 
---
Kotlin is a general purpose, free, open source, statically typed “pragmatic” programming language initially designed for the JVM (Java Virtual Machine) and Android that combines object-oriented and functional programming features.
https://www.infoworld.com/article/3224868/what-is-kotlin-the-java-alternative-explained.html
Kotlin is more concise. It’s also more type-safe, e.g. support for non-nullable types makes applications less prone to NPE’s.
https://kotlinlang.org/docs/faq.html#is-kotlin-an-object-oriented-language-or-a-functional-one
======
stack vs heap
https://www.journaldev.com/4098/java-heap-space-vs-stack-memory
=======
Lambda expressions
In languages that support first class functions, the type of the lambda expression would be a function; but in Java, the lambda expressions are represented as objects, and so they must be bound to a particular object type known as a functional interface. This is called the target type.
Since a functional interface can only have a single abstract method, the types of the lambda expression parameters must correspond to the parameters in that method, and the type of the lambda body must correspond to the return type of this method. Additionally, any exceptions thrown in the lambda body must be allowed by the throws clause of this method in the functional interface.
=========
Life cycle of a thread:
new
runnable
running
non-runnable
terminated
---
connection.prepareStatement() > PostgresConnection.getConnection() > DriverManager.getConnection() > private DriverManager.getConnection() > CopyOnWriteArrayList<DriverInfo> registeredDrivers > Driver DriverInfo.driver > Connection Driver.connect()

DriverManager.getConnection() returns a Connection object but Connection is an interface. 
I looked in the DriverManager class. The public getConnection() calls the private getConnection() which also returns a Connection object but that Connection object is assigned to by DriverInfo.driver.connect(). The driver member of DriverInfo is a Driver type which is also an interface and the Driver.connect() method also returns a Connection object. 
I thought maybe at some point one of the classes has an inner class that implements the Connection interface but I don't see it.
---
Statement.RETURN_GENERATED_KEYS
The constant indicating that generated keys should be made available for retrieval.
---
Will this work for enums?
the following code fragment specifies that the SQL type ATHLETES will be mapped to the class Athletes in the Java programming language. The code fragment retrieves the type map for the Connection object con, inserts the entry into it, and then sets the type map with the new entry as the connection's type map.
      java.util.Map map = con.getTypeMap();
      map.put("mySchemaName.ATHLETES", Class.forName("Athletes"));
      con.setTypeMap(map);
---
How to build Singleton Java class?
Disable the constructor by making it as private
keep a static method which checks and return the instance of the Connection object.
---
3 tier: 
presentation
	Main class
business (service)
	EmployeeService class
Persistence layer (Data Access Object)
	EmployeeDAO class

EmployeeMain > EmployeeService > EmployeeDAO
---
JSE Standard Edition (core)
JEE Enterprise Edition (Java on Web): JDBC
JME Micro Edition (Java on Micro devices)
---
Statement
	Executes a static SQL statement and, through a ResultSet object, returns the result

---
Connection establishes handshake with DB from java.
in enterprise apps, have 1000 requests w/ one connection utilized between 1000 requests.
---
JDBC - Java Database Connectivity. A bridge driver, an intermediary between java and sql provider/vendor. 
Steps to interact with db using jdbc
1. load or register driver. lets the driver know who db provider/vendor is.
2. open connection between java and db provider. (url, username, password)
3. create statement. 3 types of statements in sql package 
	Statement(I) values are hard-coded, passed as parameters to query which might lead to sql injection. It compiles, runs every time even if no changes in query syntax.
	PreparedStatement (I) child of Statement(I) passes the values to query by using placeholder ? which solves the problem of sql injection. PreparedStatement is a precompiled statement. it compiles query once without any values and runs multiple times.
	CallableStatement(I) extends PreparedStatement. can make a call to stored procedures and functions (PL/SQL: Procedural Language w/ SQL) in db using CallableStatement. 
	PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS
4. execute query
	boolean execute(). DDL
	int executeUpdate(). DML
	ResultSet executeQuery(). DQL. returns pointer to results set.
5. process results
6. close connection. result set disappears. 
---
// Step 2
Connection conn = PostgresConnection.getConnection();
String sql = "INSERT INTO schema_name.table_name (column1, ...) VALUES(?, ...);";
// Step 3
PreparedStatement ps = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);	
ps.setString(1, "value1"); // fill in values of parameterized query
// Step 4
int c = ps.executeUpdate(); 
if (c==1) {
	ResultSet rs = ps.getGeneratedKeys();
	if (rs.next()) model.setId(rs.getInt(1));
} else {
	throw new Exception("Could not create new record");
}
return model;
---
url 
right-click on database > edit connection > Edit driver settings > url template
---
stringbuffer came first. stringbuilder is single-thread implementation. 
---
Java naming conventions
packages: all lowercase, prefix with TLD followed by components according to the org's internal naming conventions.
Classes: nouns, camel case starting with capital letter. 
Interfaces: like class names
Methods: verbs, camel case starting with lowercase.
Variables: camel case starting with lower case, don't start with _ or $.
Constants: all uppercase, words separated by _
---
log4j configuration in main/resources
---
3 main components of Logging
- Logger component
	log levels: 1:trace, 2:debug, 3:info,4:warn,5:error,6:fatal
	log configuration: log4j.properties(K,V)
- Appender component
	append to console,file,db
- Layout component
---
public class Demo {
	public static void main() {
		sout("main");
		sout("object 1");
		Demo d1 = new Demo();
		sout("object 2");
		Demo d2 = new Demo();
	}
	public Demo() {
		sout("Constructor")
	}
	static {
		sout("static block");
	}
	{
		sout("anonymous block");
	}
}
Output:
static block
main
object 1
anonymous block
constructor
object 2
anonymous block
constructor
---
COLLECTIONS

Collection I
+-List I ordered collection w/ duplicates. positional access. extended iterator. 
| +-ArrayList C resizeable array. permits null. unsynchronized.
| +-LinkedList C doubly-linked. implements List, Queue & Deque. permits null.
+-Set I unordered, no duplicates
| +-SortedSet I value-based ordering (or Comparator)
| +-HashSet C best-performing, no guarantee on order of iteration. permits null.
| +-TreeSet C implements SortedSet. uses red-black tree, slower than HashSet--log(n)
| +-LinkedHashSet C hash table w/ doubly-linked list. maintains insertion order. 
+-Queue I FIFO order. insert at tail, remove from head
+-Deque I implements Stack & Queue. 

Map I key/value pairs. no duplicates. collection views: keySet, entrySet, values.
+-SortedMap I key-based ordering (or Comparator)
+-HashMap C permits null values & null key. no guarantee of ordering. O(1) performance. 
+-LinkedHashMap C hash table w/ doubly-linked list. maintains insertion order. 
+-TreeMap C implements SortedMap. 

Hashtable does not permit nulls

***
(I: interface, C: Class)
Collection (I)
-List (I)
--Vector (C)
	uses array
	starts with 10 elements increases by 10
	memory is contiguous
	is legacy class (backwards compatible) and thread safe
--ArrayList (C)
	starts w/ 10 increases by 1.5
	memory is contiguous
	not thread safe
--LinkedList (C)
	starts w/ 1 increases by 1
	doesn't use array, maintains node structure
	can work as List, Queue, Dequeue
	memory is random, not contiguous
	not thread safe
-Queue (I)
--LinkedList (C)
--PriorityQueue (C)
-Set (I)
	no duplicates, no index, unordered
--HashSet (C)
	does not preserve order of insertion
	allows one null value
---LinkedHashSet (C)
	maintains order of insertion
	uses equals() and hashcode()
--SortedSet (I)
---NavigableSet (I)
----TreeSet (C)
	stored in sorted order based on comparator
	null not allowed

Collections
	helper class w/ static methods
Collections.sort() calls Comparable or Comparator Functional interface
Comparable 
	in java.lang
	int compareTo(object): definition should be in Model class
	
Comparator 
	in java.util
	int compare(Object o1, Object o2)
		definition can be anywhere effectively can make use of lambda 

Map<K,V> (I)
--HashMap (C)
---HashSet (C)
---LinkedHashMap (C)
---NavigableMap (I)
----TreeMap (C)
--Hashtable (C)
	no null, thread safe, legacy

interface methods are public & abstract by default
interface properties are static & final by default
Lambda is only applicable on functional interfaces
left hand side of assignment should be the interface and right hand side should be its implementing class
List l = new LinkedList();
Queue q = new LinkedList();
Dequeue dq = new LinkedList();
---
java.util.Arrays
Arrays.toString()

Problem: Getting errors/warnings in IntelliJ, but it was still compiling and running.
Solution: File > Invalidate caches > Check all three boxes > Invalidate and Restart
---
Java Print address of object 
System.identityHashCode(x)
---
// create string outside of common string pool
String s1 = new String("hello");
// move back into common string pool
s1=s1.intern();
